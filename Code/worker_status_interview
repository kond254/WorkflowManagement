import asyncio

from pyzeebe import create_insecure_channel, ZeebeWorker, Job
import random
from clientWeplacm import *
from db import Databank 
import random   
import datetime
import time
from array import array

def main():
    channel = create_insecure_channel(hostname="141.26.157.71",
                                      port=26500)
    
    print("Channel created")
    db = Databank()
    worker = ZeebeWorker(channel)

    
    # create also variables as dbcount and countvar for later stages 
    @worker.task(task_type="checkTopCandidatesAmount")
    async def check_top_candidates_amount(job: Job):
        candidates_in_top_db = db.create_Array_for_MultiInstance(job.process_instance_key)
        return {"remainingCandidatesInTopDB": db.check_amount_of_candidates_in_TopCandidateDB(job.process_instance_key)[0][0]>0, "countDB": (len(candidates_in_top_db)), "countVar": 0, "RemainingCandidates": candidates_in_top_db, "Beginn": "", "InterviewDate":"", "End":"" }
    
        
    @worker.task(task_type="checkEntrysInCandidateDB")
    async def check_candidates_amount(job: Job):
        
        return {"remainingCandidatesInDB": db.check_amount_of_candidates_in_CandidateDB(job.process_instance_key)[0][0]}
    
    
    
    
    @worker.task(task_type="checkInterviewDate")
    async def check_interview_date(job: Job, countVar: int, RemainingCandidates: list):
        target_date = None
        target_start_time = None
        target_end_time = None
        while(True):        
            start_date =datetime.datetime.now() + datetime.timedelta(days=7)
            end_date = start_date + datetime.timedelta(days=30)
            random_date = start_date + datetime.timedelta(days=random.randint(0, (end_date - start_date).days))

            hour = random.randint(8, 16)
            minute = random.choice(['00', '15', '30', '45'])

            target_date = random_date.strftime("%Y-%m-%d")
            target_start_time=f'{hour}:{minute}'
            target_end_time=f'{hour+1}:{minute}'
            print(f'{target_date} _ {target_start_time} - {target_end_time}')
            if db.check_interview_dates(target_date, target_start_time, target_end_time):
                print('Time found')
                break
            time.sleep(5)
            
        #date found --> make entry in db
        event_ids = db.make_entry_in_calendar(target_date, target_start_time, target_end_time, RemainingCandidates[countVar])
        time.sleep(5)
        print(countVar)
        print(RemainingCandidates)
        countVar+=1
        return{"countVar": countVar, "InterviewDate": target_date, "Beginn": target_start_time, "End": target_end_time, "CandidateID": RemainingCandidates[countVar-1], "EventIDs": event_ids}
        
          
    @worker.task(task_type="checkInterviewerAnswer")
    async def check_interviewer_answer(job: Job, hrRepAnswer: str, hrManagerAnswer: str, vpAnswer: str):
        if hrRepAnswer == "False" or hrManagerAnswer== "Flase" or vpAnswer =="False":
            return{"onlyConfirmations": False}
        else:
            return{"onlyConfirmations": True}
        
    @worker.task(task_type="storeDateAnswer")
    async def store_date_answer(job: Job, CandidateID: int, InterviewAccepted: bool):
        db.store_answer(InterviewAccepted, CandidateID)
        

    @worker.task(task_type="checkingDateAnswers")
    async def checking_date_answers(job: Job):
        posAnswers = db.checking_date_answers(job.process_instance_key)[0][0]
        entrysInDb = db.check_amount_of_candidates_in_TopCandidateDB(job.process_instance_key)[0][0]
        percentage = (posAnswers/entrysInDb)*100
        if percentage > 60:
            return{"percentage": True}
        else:
            return{"percentage": False}
        
    @worker.task(task_type="removeDeclinedCandidates")
    async def delete_candidates_declined_interview(job: Job):
        db.delete_TopCandidates(job.process_instance_key)
        
    @worker.task(task_type="deleteConflictingInterviews")
    async def delete_company_calendry_entries(job: Job):
        print("Deleting Conflicting Interviews")
        candidates_in_top_db=db.delete_calendry_entries(job.process_instance_key)
        time.sleep(60)
        return {"RemainingCandidates": candidates_in_top_db, "countVar": 0}
        
            
    
    
    @worker.task(task_type="orderByDate")
    async def order_TopCandidates_by_interview(job: Job):
        return {"InterviewOrder": db.order_by_interview(job.process_instance_key)}

    @worker.task(task_type="cancelInterviewDateWithInterviewers")
    async def cancle_interview_date_with_interviewers(job: Job, CandidateID: int):
        db.delete_TopCandidate_due_Candidate_rejection(CandidateID)
        return {"InterviewOrder": db.order_by_interview(job.process_instance_key)}

    
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(worker.work())
    except KeyboardInterrupt:
        pass


if __name__ == '__main__':
    main()
